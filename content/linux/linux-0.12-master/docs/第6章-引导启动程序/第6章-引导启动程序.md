<!-- TOC depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->

- [第6章-引导启动程序](#第6章-引导启动程序)
	- [总结](#总结)
		- [总体功能](#总体功能)
		- [setup.S程序](#setups程序)
		- [head.s程序](#heads程序)

<!-- /TOC -->
# 第6章-引导启动程序

## 总结

![1529373041178.png](image/1529373041178.png)

![1529373054052.png](image/1529373054052.png)

![1529373063852.png](image/1529373063852.png)

![1529373078289.png](image/1529373078289.png)



### 总体功能

* 为嘛要用ld86和as86然后再用GNU as和 GNU ld，因为当时GNU相关的工具不支持运行于16位代码程序。没有考虑过这个需求，所以Linus使用了两套工具。
* 这里再一次体现了Linus对GNU工具的依赖，所以当之无愧应该叫GNU/Linux
* 知道1994年GNU as才开始支持16位代码专用伪指令.code16
* 直到2.4内核才统一使用as来编写启动代码

![1528848828332.png](image/1528848828332.png)

![1528848862097.png](image/1528848862097.png)

这图画的真棒~

![1528851975844.png](image/1528851975844.png)

* 从0x7c00到0x000A,0000都是可以直接使用，不在BIOS部署的特定地址用途地址空间。**640KB-50B**

![1528850280363.png](image/1528850280363.png)

![1528850976538.png](image/1528850976538.png)

* system不是由setup.S加载，也是由bootsec.S加载。

![1528851646639.png](image/1528851646639.png)

### setup.S程序

![1528853149504.png](image/1528853149504.png)

* CPU在进入保护模式之前需要设定IDT表，因此在setup.S设定了一个长度为0的空表。

![1528854278233.png](image/1528854278233.png)

* 原来的启动扇区加载的地方用来存放使用BIOS中断获取到的参数

![1528856232336.png](image/1528856232336.png)

![1530935343694.png](image/1530935343694.png)

* 通过BIOS获取一大波参数，同时低级初始化一波设备
* 中断控制器，这里讲的非常简单通俗易懂，看了就懂，没毛病

![1530935416366.png](image/1530935416366.png)



### head.s程序

![1528854509909.png](image/1528854509909.png)

![1528855169293.png](image/1528855169293.png)

![1528856174746.png](image/1528856174746.png)

![1528856210406.png](image/1528856210406.png)
