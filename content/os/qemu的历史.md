>[!tldr]
> KVM完成CPU和内存的模拟
> 
> QEMU完成用户组件的模拟 

QEMU和KVM经常被人们放在一起讨论，其实两者的关系完全可以解耦合。

QEMU最开始是由法国程序员FabriceBellard开发的一个模拟器。

QEMU能够完成**用户程序模拟**和**系统虚拟化模拟**。

**用户程序模拟**指的是QEMU能够将为一个平台编译的二进制文件运行在另一个不同的平台，如一个ARM指令集的二进制程序，通过QEMU的**TCG**（TinyCodeGenerator）引擎的处理之后，ARM指令被转换成TCG中间代码，然后再转换成目的平台的代码。

**系统虚拟化模拟**指的是QEMU能够模拟一个完整的系统虚拟机，该虚拟机有自己的虚拟CPU、芯片组、虚拟内存以及各种虚拟外部设备，能够为虚拟机中运行的操作系统和应用软件呈现出与物理计算机完全一致的**硬件视图**。

QEMU能够模拟的平台很多，包括x86、ARM、MIPS、PPC等，早期QEMU都是通过TCG来完成各种硬件平台的模拟，所有的虚拟机指令需要经QEMU的转换。

系统虚拟机天生适用于**云计算**。
**云计算**提供了一种按需服务的模式，让用户能够很方便地根据自己的需求使用各种计算、网络、存储资源。
以计算资源中的虚拟机为例，用户可以指定不同CPU模型和内存规格的虚拟机。
云计算平台可以通过系统虚拟化技术很方便地满足用户的需求。如果用户删除资源，云计算平台可以直接删除其对应的虚拟机。

早期的QEMU都是软件模拟的，很明显其在性能上是不能满足要求的。所以早期的云计算平台通常使用Xen作为其底层虚拟化平台。
前面提到过，[[Xen]]早期是在x86架构上直接完成的虚拟化，这需要修改虚拟机内部的操作系统，也使得Xen的整个[[VMM]]非常复杂，缺陷比较多。

Intel和AMD在2005年左右开始在CPU层面提供对**系统虚拟化**的支持，叫作硬件虚拟化，Intel在x86指令集的基础上增加了一套VMX扩展指令VT-x，为CPU增加了新的运行模式，完成了x86虚拟化漏洞的修补。
通过新的**硬件虚拟化指令**，可以非常方便地构造VMM，并且x86虚拟机中的代码能够原生地运行在物理CPU上。

以色列初创公司Qumranet基于新的虚拟化指令集实现了KVM，并推广到Linux内核社区。

[[KVM]]本身是一个内核模块，导出了一系列的接口到用户空间，用户空间可以使用这些接口创建虚拟机。最开始KVM只负责最核心的**CPU虚拟化**和内存虚拟化部分，使用**QEMU**作为其用户态组件，负责完成大量外设的模拟，当时的方案被称为QEMU-KVM。

KVM的具体设计与实现可以参考AviKivity等人在2007年发表的论文“KVM: The Linux Virtual Machine Monitor”。由于KVM的设计架构精简，能够跟现有的Linux内核无缝吻合，因此在社区获得了极大的关注与支持。

特别是随着RedHat投入大量的人力去完善QEMU和KVM，QEMU社区得到了飞速发展。直到现在，QEMU社区依然非常活跃，但是其主要用途已经不是作为一个模拟器了，而是作为以QEMU-KVM为基础的为云计算服务的系统虚拟化软件。当然，不仅仅是KVM将QEMU作为应用层组件，Xen后来支持的硬件虚拟机也使用QEMU作为其用户态组件来完成虚拟机的设备模拟